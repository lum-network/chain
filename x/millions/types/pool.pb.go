// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lum/network/millions/pool.proto

package types

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PoolState the state of a Pool
// Deposits are only accepted for Pools in a Ready state
//
// TODO:
// Pool state KILLED is not available in the current implementation
// Introduce the capability to:
// - Kill a Pool and withdraw or migrate all deposits to another Pool via
// Governance proposal
type PoolState int32

const (
	PoolState_Unspecified PoolState = 0
	PoolState_Created     PoolState = 1
	PoolState_Ready       PoolState = 2
	PoolState_Paused      PoolState = 3
	PoolState_Killed      PoolState = 4
)

var PoolState_name = map[int32]string{
	0: "POOL_STATE_UNSPECIFIED",
	1: "POOL_STATE_CREATED",
	2: "POOL_STATE_READY",
	3: "POOL_STATE_PAUSED",
	4: "POOL_STATE_KILLED",
}

var PoolState_value = map[string]int32{
	"POOL_STATE_UNSPECIFIED": 0,
	"POOL_STATE_CREATED":     1,
	"POOL_STATE_READY":       2,
	"POOL_STATE_PAUSED":      3,
	"POOL_STATE_KILLED":      4,
}

func (x PoolState) String() string {
	return proto.EnumName(PoolState_name, int32(x))
}

func (PoolState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1401529e8cac8ff, []int{0}
}

// PoolType the type of Pool
// Each PoolType implements a dedicated runner which applies its own Pool
// Lifecycle in order to deliver yield and distribute prizes
type PoolType int32

const (
	PoolType_Unspecified PoolType = 0
	PoolType_Staking     PoolType = 1
)

var PoolType_name = map[int32]string{
	0: "POOL_TYPE_UNSPECIFIED",
	1: "POOL_TYPE_STAKING",
}

var PoolType_value = map[string]int32{
	"POOL_TYPE_UNSPECIFIED": 0,
	"POOL_TYPE_STAKING":     1,
}

func (x PoolType) String() string {
	return proto.EnumName(PoolType_name, int32(x))
}

func (PoolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c1401529e8cac8ff, []int{1}
}

type FeeTaker struct {
	Address string                                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Amount  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *FeeTaker) Reset()         { *m = FeeTaker{} }
func (m *FeeTaker) String() string { return proto.CompactTextString(m) }
func (*FeeTaker) ProtoMessage()    {}
func (*FeeTaker) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1401529e8cac8ff, []int{0}
}
func (m *FeeTaker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeTaker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeTaker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeTaker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeTaker.Merge(m, src)
}
func (m *FeeTaker) XXX_Size() int {
	return m.Size()
}
func (m *FeeTaker) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeTaker.DiscardUnknown(m)
}

var xxx_messageInfo_FeeTaker proto.InternalMessageInfo

func (m *FeeTaker) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type Pool struct {
	PoolId              uint64                                 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	Denom               string                                 `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	NativeDenom         string                                 `protobuf:"bytes,3,opt,name=native_denom,json=nativeDenom,proto3" json:"native_denom,omitempty"`
	ChainId             string                                 `protobuf:"bytes,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	ConnectionId        string                                 `protobuf:"bytes,5,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	TransferChannelId   string                                 `protobuf:"bytes,6,opt,name=transfer_channel_id,json=transferChannelId,proto3" json:"transfer_channel_id,omitempty"`
	IcaDepositPortId    string                                 `protobuf:"bytes,7,opt,name=ica_deposit_port_id,json=icaDepositPortId,proto3" json:"ica_deposit_port_id,omitempty"`
	IcaPrizepoolPortId  string                                 `protobuf:"bytes,8,opt,name=ica_prizepool_port_id,json=icaPrizepoolPortId,proto3" json:"ica_prizepool_port_id,omitempty"`
	PoolType            PoolType                               `protobuf:"varint,9,opt,name=pool_type,json=poolType,proto3,enum=lum.network.millions.PoolType" json:"pool_type,omitempty"`
	Validators          []PoolValidator                        `protobuf:"bytes,10,rep,name=validators,proto3" json:"validators"`
	Bech32PrefixAccAddr string                                 `protobuf:"bytes,11,opt,name=bech32_prefix_acc_addr,json=bech32PrefixAccAddr,proto3" json:"bech32_prefix_acc_addr,omitempty"`
	Bech32PrefixValAddr string                                 `protobuf:"bytes,12,opt,name=bech32_prefix_val_addr,json=bech32PrefixValAddr,proto3" json:"bech32_prefix_val_addr,omitempty"`
	MinDepositAmount    github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,13,opt,name=min_deposit_amount,json=minDepositAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"min_deposit_amount"`
	DrawSchedule        DrawSchedule                           `protobuf:"bytes,14,opt,name=draw_schedule,json=drawSchedule,proto3" json:"draw_schedule"`
	PrizeStrategy       PrizeStrategy                          `protobuf:"bytes,15,opt,name=prize_strategy,json=prizeStrategy,proto3" json:"prize_strategy"`
	UnbondingDuration   time.Duration                          `protobuf:"bytes,16,opt,name=unbonding_duration,json=unbondingDuration,proto3,stdduration" json:"unbonding_duration"`
	MaxUnbondingEntries github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,17,opt,name=max_unbonding_entries,json=maxUnbondingEntries,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_unbonding_entries"`
	LocalAddress        string                                 `protobuf:"bytes,18,opt,name=local_address,json=localAddress,proto3" json:"local_address,omitempty"`
	IcaDepositAddress   string                                 `protobuf:"bytes,19,opt,name=ica_deposit_address,json=icaDepositAddress,proto3" json:"ica_deposit_address,omitempty"`
	IcaPrizepoolAddress string                                 `protobuf:"bytes,20,opt,name=ica_prizepool_address,json=icaPrizepoolAddress,proto3" json:"ica_prizepool_address,omitempty"`
	NextDrawId          uint64                                 `protobuf:"varint,22,opt,name=next_draw_id,json=nextDrawId,proto3" json:"next_draw_id,omitempty"`
	TvlAmount           github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,23,opt,name=tvl_amount,json=tvlAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"tvl_amount"`
	DepositorsCount     uint64                                 `protobuf:"varint,24,opt,name=depositors_count,json=depositorsCount,proto3" json:"depositors_count,omitempty"`
	SponsorshipAmount   github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,25,opt,name=sponsorship_amount,json=sponsorshipAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"sponsorship_amount"`
	LastDrawCreatedAt   *time.Time                             `protobuf:"bytes,27,opt,name=last_draw_created_at,json=lastDrawCreatedAt,proto3,stdtime" json:"last_draw_created_at,omitempty"`
	LastDrawState       DrawState                              `protobuf:"varint,28,opt,name=last_draw_state,json=lastDrawState,proto3,enum=lum.network.millions.DrawState" json:"last_draw_state,omitempty"`
	AvailablePrizePool  types1.Coin                            `protobuf:"bytes,29,opt,name=available_prize_pool,json=availablePrizePool,proto3" json:"available_prize_pool"`
	FeeTakers           []*FeeTaker                            `protobuf:"bytes,30,rep,name=fee_takers,json=feeTakers,proto3" json:"fee_takers,omitempty"`
	State               PoolState                              `protobuf:"varint,32,opt,name=state,proto3,enum=lum.network.millions.PoolState" json:"state,omitempty"`
	CreatedAtHeight     int64                                  `protobuf:"varint,33,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	UpdatedAtHeight     int64                                  `protobuf:"varint,34,opt,name=updated_at_height,json=updatedAtHeight,proto3" json:"updated_at_height,omitempty"`
	CreatedAt           time.Time                              `protobuf:"bytes,35,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at"`
	UpdatedAt           time.Time                              `protobuf:"bytes,36,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at"`
}

func (m *Pool) Reset()         { *m = Pool{} }
func (m *Pool) String() string { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()    {}
func (*Pool) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1401529e8cac8ff, []int{1}
}
func (m *Pool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pool.Merge(m, src)
}
func (m *Pool) XXX_Size() int {
	return m.Size()
}
func (m *Pool) XXX_DiscardUnknown() {
	xxx_messageInfo_Pool.DiscardUnknown(m)
}

var xxx_messageInfo_Pool proto.InternalMessageInfo

func (m *Pool) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Pool) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *Pool) GetNativeDenom() string {
	if m != nil {
		return m.NativeDenom
	}
	return ""
}

func (m *Pool) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *Pool) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *Pool) GetTransferChannelId() string {
	if m != nil {
		return m.TransferChannelId
	}
	return ""
}

func (m *Pool) GetIcaDepositPortId() string {
	if m != nil {
		return m.IcaDepositPortId
	}
	return ""
}

func (m *Pool) GetIcaPrizepoolPortId() string {
	if m != nil {
		return m.IcaPrizepoolPortId
	}
	return ""
}

func (m *Pool) GetPoolType() PoolType {
	if m != nil {
		return m.PoolType
	}
	return PoolType_Unspecified
}

func (m *Pool) GetValidators() []PoolValidator {
	if m != nil {
		return m.Validators
	}
	return nil
}

func (m *Pool) GetBech32PrefixAccAddr() string {
	if m != nil {
		return m.Bech32PrefixAccAddr
	}
	return ""
}

func (m *Pool) GetBech32PrefixValAddr() string {
	if m != nil {
		return m.Bech32PrefixValAddr
	}
	return ""
}

func (m *Pool) GetDrawSchedule() DrawSchedule {
	if m != nil {
		return m.DrawSchedule
	}
	return DrawSchedule{}
}

func (m *Pool) GetPrizeStrategy() PrizeStrategy {
	if m != nil {
		return m.PrizeStrategy
	}
	return PrizeStrategy{}
}

func (m *Pool) GetUnbondingDuration() time.Duration {
	if m != nil {
		return m.UnbondingDuration
	}
	return 0
}

func (m *Pool) GetLocalAddress() string {
	if m != nil {
		return m.LocalAddress
	}
	return ""
}

func (m *Pool) GetIcaDepositAddress() string {
	if m != nil {
		return m.IcaDepositAddress
	}
	return ""
}

func (m *Pool) GetIcaPrizepoolAddress() string {
	if m != nil {
		return m.IcaPrizepoolAddress
	}
	return ""
}

func (m *Pool) GetNextDrawId() uint64 {
	if m != nil {
		return m.NextDrawId
	}
	return 0
}

func (m *Pool) GetDepositorsCount() uint64 {
	if m != nil {
		return m.DepositorsCount
	}
	return 0
}

func (m *Pool) GetLastDrawCreatedAt() *time.Time {
	if m != nil {
		return m.LastDrawCreatedAt
	}
	return nil
}

func (m *Pool) GetLastDrawState() DrawState {
	if m != nil {
		return m.LastDrawState
	}
	return DrawState_Unspecified
}

func (m *Pool) GetAvailablePrizePool() types1.Coin {
	if m != nil {
		return m.AvailablePrizePool
	}
	return types1.Coin{}
}

func (m *Pool) GetFeeTakers() []*FeeTaker {
	if m != nil {
		return m.FeeTakers
	}
	return nil
}

func (m *Pool) GetState() PoolState {
	if m != nil {
		return m.State
	}
	return PoolState_Unspecified
}

func (m *Pool) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *Pool) GetUpdatedAtHeight() int64 {
	if m != nil {
		return m.UpdatedAtHeight
	}
	return 0
}

func (m *Pool) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Pool) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

type PoolValidator struct {
	OperatorAddress string                                 `protobuf:"bytes,1,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	IsEnabled       bool                                   `protobuf:"varint,2,opt,name=is_enabled,json=isEnabled,proto3" json:"is_enabled,omitempty"`
	BondedAmount    github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=bonded_amount,json=bondedAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"bonded_amount"`
}

func (m *PoolValidator) Reset()         { *m = PoolValidator{} }
func (m *PoolValidator) String() string { return proto.CompactTextString(m) }
func (*PoolValidator) ProtoMessage()    {}
func (*PoolValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_c1401529e8cac8ff, []int{2}
}
func (m *PoolValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolValidator.Merge(m, src)
}
func (m *PoolValidator) XXX_Size() int {
	return m.Size()
}
func (m *PoolValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolValidator.DiscardUnknown(m)
}

var xxx_messageInfo_PoolValidator proto.InternalMessageInfo

func (m *PoolValidator) GetOperatorAddress() string {
	if m != nil {
		return m.OperatorAddress
	}
	return ""
}

func (m *PoolValidator) GetIsEnabled() bool {
	if m != nil {
		return m.IsEnabled
	}
	return false
}

func init() {
	proto.RegisterEnum("lum.network.millions.PoolState", PoolState_name, PoolState_value)
	proto.RegisterEnum("lum.network.millions.PoolType", PoolType_name, PoolType_value)
	proto.RegisterType((*FeeTaker)(nil), "lum.network.millions.FeeTaker")
	proto.RegisterType((*Pool)(nil), "lum.network.millions.Pool")
	proto.RegisterType((*PoolValidator)(nil), "lum.network.millions.PoolValidator")
}

func init() { proto.RegisterFile("lum/network/millions/pool.proto", fileDescriptor_c1401529e8cac8ff) }

var fileDescriptor_c1401529e8cac8ff = []byte{
	// 1341 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4d, 0x4f, 0x1b, 0xc7,
	0x1b, 0x67, 0x83, 0x01, 0x7b, 0xc0, 0x61, 0x19, 0x5e, 0xb2, 0x38, 0xff, 0xd8, 0x0e, 0xf9, 0xab,
	0x22, 0x54, 0xac, 0x15, 0xa2, 0x9e, 0xaa, 0x1c, 0x8c, 0xed, 0x24, 0x4e, 0x48, 0xe2, 0xae, 0x4d,
	0xa4, 0x54, 0xad, 0xb6, 0xe3, 0xdd, 0xc1, 0x1e, 0xb1, 0xbb, 0xb3, 0xda, 0x1d, 0x13, 0xe8, 0xb1,
	0x87, 0xaa, 0xe2, 0x94, 0x63, 0x2f, 0x9c, 0xfa, 0x15, 0xfa, 0x21, 0xa2, 0x9e, 0xa2, 0x9e, 0xaa,
	0x1e, 0xd2, 0x2a, 0xf9, 0x22, 0xd5, 0xbc, 0x61, 0x43, 0x20, 0x24, 0x9c, 0x76, 0xe7, 0x79, 0x7e,
	0xcf, 0x6f, 0xe6, 0x79, 0x9d, 0x01, 0xa5, 0x60, 0x10, 0x56, 0x22, 0xcc, 0x5e, 0xd2, 0x64, 0xb7,
	0x12, 0x92, 0x20, 0x20, 0x34, 0x4a, 0x2b, 0x31, 0xa5, 0x81, 0x1d, 0x27, 0x94, 0x51, 0xb8, 0x10,
	0x0c, 0x42, 0x5b, 0x01, 0x6c, 0x0d, 0x28, 0x2c, 0xf4, 0x68, 0x8f, 0x0a, 0x40, 0x85, 0xff, 0x49,
	0x6c, 0xa1, 0xd8, 0xa3, 0xb4, 0x17, 0xe0, 0x8a, 0x58, 0x75, 0x07, 0x3b, 0x15, 0x7f, 0x90, 0x20,
	0x46, 0x68, 0xa4, 0xf4, 0xa5, 0xd3, 0x7a, 0x46, 0x42, 0x9c, 0x32, 0x14, 0xc6, 0x9a, 0xc0, 0xa3,
	0x69, 0x48, 0xd3, 0x4a, 0x17, 0xa5, 0xb8, 0xb2, 0x77, 0xa7, 0x8b, 0x19, 0xba, 0x53, 0xf1, 0x28,
	0xd1, 0x04, 0xcb, 0x52, 0xef, 0xca, 0x9d, 0xe5, 0x42, 0x73, 0x9f, 0xe9, 0x88, 0x9f, 0xa0, 0x97,
	0x0a, 0xb0, 0x7a, 0x2e, 0xc0, 0x4d, 0xbd, 0x3e, 0xf6, 0x07, 0x01, 0x56, 0xc8, 0xdb, 0x67, 0xc7,
	0x24, 0x21, 0x3f, 0x62, 0x37, 0x65, 0x09, 0x62, 0xb8, 0x77, 0x20, 0xa1, 0x2b, 0x3f, 0x1b, 0x20,
	0x7b, 0x1f, 0xe3, 0x0e, 0xda, 0xc5, 0x09, 0xdc, 0x00, 0x53, 0xc8, 0xf7, 0x13, 0x9c, 0xa6, 0x96,
	0x51, 0x36, 0x56, 0x73, 0x9b, 0xd6, 0x9f, 0xbf, 0xaf, 0x2f, 0xa8, 0x53, 0x56, 0xa5, 0xa6, 0xcd,
	0x12, 0x12, 0xf5, 0x1c, 0x0d, 0x84, 0xf7, 0xc1, 0x24, 0x0a, 0xe9, 0x20, 0x62, 0xd6, 0x15, 0x61,
	0x62, 0xbf, 0x7e, 0x5b, 0x1a, 0xfb, 0xfb, 0x6d, 0xe9, 0x8b, 0x1e, 0x61, 0xfd, 0x41, 0xd7, 0xf6,
	0x68, 0xa8, 0xfc, 0x54, 0x9f, 0xf5, 0xd4, 0xdf, 0xad, 0xb0, 0x83, 0x18, 0xa7, 0x76, 0x1d, 0x7b,
	0x8e, 0xb2, 0x5e, 0xf9, 0xc9, 0x04, 0x99, 0x16, 0xa5, 0x01, 0xbc, 0x06, 0xa6, 0x78, 0xf6, 0x5c,
	0xe2, 0x8b, 0x43, 0x64, 0x9c, 0x49, 0xbe, 0x6c, 0xfa, 0x70, 0x01, 0x4c, 0xf8, 0x38, 0xa2, 0xa1,
	0xdc, 0xc8, 0x91, 0x0b, 0x78, 0x13, 0xcc, 0x44, 0x88, 0x91, 0x3d, 0xec, 0x4a, 0xe5, 0xb8, 0x50,
	0x4e, 0x4b, 0x59, 0x5d, 0x40, 0x96, 0x41, 0xd6, 0xeb, 0x23, 0x12, 0x71, 0xca, 0x8c, 0x50, 0x4f,
	0x89, 0x75, 0xd3, 0x87, 0xb7, 0x40, 0xde, 0xa3, 0x51, 0x84, 0x3d, 0x9e, 0x64, 0xae, 0x9f, 0x10,
	0xfa, 0x99, 0xa1, 0xb0, 0xe9, 0x43, 0x1b, 0xcc, 0xb3, 0x04, 0x45, 0xe9, 0x0e, 0x4e, 0x5c, 0xaf,
	0x8f, 0xa2, 0x08, 0x8b, 0xd3, 0x4d, 0x0a, 0xe8, 0x9c, 0x56, 0xd5, 0xa4, 0xa6, 0xe9, 0xc3, 0x75,
	0x30, 0x4f, 0x3c, 0xe4, 0xfa, 0x38, 0xa6, 0x29, 0x61, 0x6e, 0x4c, 0x13, 0xc6, 0xf1, 0x53, 0x02,
	0x6f, 0x12, 0x0f, 0xd5, 0xa5, 0xa6, 0x45, 0x13, 0xd6, 0xf4, 0xe1, 0x1d, 0xb0, 0xc8, 0xe1, 0x22,
	0x3d, 0xc2, 0x73, 0x6d, 0x90, 0x15, 0x06, 0x90, 0x78, 0xa8, 0xa5, 0x75, 0xca, 0xe4, 0x6b, 0x90,
	0x13, 0x48, 0x1e, 0x46, 0x2b, 0x57, 0x36, 0x56, 0xaf, 0x6e, 0x14, 0xed, 0xb3, 0xea, 0xdc, 0xe6,
	0x21, 0xed, 0x1c, 0xc4, 0xd8, 0xc9, 0xc6, 0xea, 0x0f, 0x36, 0x01, 0xd8, 0x43, 0x01, 0xf1, 0x11,
	0xa3, 0x49, 0x6a, 0x81, 0xf2, 0xf8, 0xea, 0xf4, 0xc6, 0xad, 0xf3, 0xad, 0x9f, 0x6b, 0xec, 0x66,
	0x86, 0xa7, 0xd6, 0x19, 0x31, 0x86, 0x77, 0xc1, 0x52, 0x17, 0x7b, 0xfd, 0xbb, 0x1b, 0x6e, 0x9c,
	0xe0, 0x1d, 0xb2, 0xef, 0x22, 0xcf, 0x73, 0x79, 0x65, 0x58, 0xd3, 0xe2, 0xec, 0xf3, 0x52, 0xdb,
	0x12, 0xca, 0xaa, 0xe7, 0xf1, 0x1a, 0xfa, 0xd0, 0x68, 0x0f, 0x05, 0xd2, 0x68, 0xe6, 0x43, 0xa3,
	0xe7, 0x28, 0x10, 0x46, 0xdf, 0x01, 0x18, 0x92, 0xe8, 0x38, 0xa6, 0xaa, 0xe4, 0xf2, 0x9f, 0x5d,
	0x72, 0xcd, 0x88, 0x39, 0x66, 0x48, 0x22, 0x95, 0x82, 0xaa, 0xe0, 0x81, 0x4f, 0x40, 0xfe, 0x44,
	0x1f, 0x59, 0x57, 0xcb, 0xc6, 0xea, 0xf4, 0xc6, 0xca, 0xd9, 0x51, 0xa9, 0x27, 0xe8, 0x65, 0x5b,
	0x21, 0x55, 0x50, 0x66, 0xfc, 0x11, 0x19, 0x6c, 0x81, 0xab, 0x27, 0x9b, 0xcd, 0x9a, 0x15, 0x7c,
	0xe7, 0x45, 0x99, 0x63, 0xdb, 0x0a, 0xaa, 0x08, 0xf3, 0xf1, 0xa8, 0x10, 0x3a, 0x00, 0x0e, 0xa2,
	0x2e, 0x8d, 0x7c, 0x12, 0xf5, 0x5c, 0x3d, 0x94, 0x2c, 0x53, 0xb0, 0x2e, 0xdb, 0x72, 0x2a, 0xd9,
	0x7a, 0x2a, 0xd9, 0x75, 0x05, 0xd8, 0xcc, 0x72, 0xae, 0x5f, 0xff, 0x29, 0x19, 0xce, 0xdc, 0xb1,
	0xb9, 0x56, 0xc2, 0x2e, 0x58, 0x0c, 0xd1, 0xbe, 0x3b, 0xe4, 0xc5, 0x11, 0x4b, 0x08, 0x4e, 0xad,
	0xb9, 0x4b, 0x45, 0x75, 0x3e, 0x44, 0xfb, 0xdb, 0x9a, 0xab, 0x21, 0xa9, 0xe0, 0x3d, 0x90, 0x0f,
	0xa8, 0xa7, 0xf2, 0xcb, 0xe7, 0x0a, 0xbc, 0x60, 0xae, 0xcc, 0x08, 0xb8, 0x92, 0xc1, 0x87, 0x27,
	0x3b, 0x49, 0x93, 0xcc, 0x5f, 0x40, 0x32, 0x37, 0xec, 0x31, 0xcd, 0xb4, 0x75, 0xba, 0xc9, 0x34,
	0xd7, 0xc2, 0x05, 0x5c, 0xf3, 0xa3, 0xed, 0xa7, 0xd9, 0xca, 0x60, 0x26, 0xc2, 0xfb, 0xcc, 0x15,
	0x45, 0x43, 0x7c, 0x6b, 0x49, 0x0c, 0x2a, 0xc0, 0x65, 0xbc, 0x38, 0x9a, 0x3e, 0x7c, 0x02, 0x00,
	0xdb, 0x0b, 0x74, 0x9d, 0x5e, 0xbb, 0x54, 0x44, 0x73, 0x6c, 0x2f, 0x50, 0x05, 0x7a, 0x1b, 0x98,
	0x2a, 0x08, 0x34, 0x49, 0x5d, 0x4f, 0x90, 0x5a, 0x62, 0xd3, 0xd9, 0xa1, 0xbc, 0x26, 0xa0, 0xdf,
	0x03, 0x98, 0xc6, 0x34, 0x4a, 0x69, 0x92, 0xf6, 0x49, 0xac, 0x4f, 0xb0, 0x7c, 0xa9, 0x13, 0xcc,
	0x8d, 0x30, 0xa9, 0x93, 0x6c, 0x83, 0x85, 0x00, 0xa5, 0xca, 0x75, 0x2f, 0xc1, 0x88, 0x61, 0xdf,
	0x45, 0xcc, 0xba, 0x2e, 0x6a, 0xb1, 0xf0, 0x41, 0x2d, 0x76, 0xf4, 0x0d, 0x29, 0x8a, 0xd1, 0x78,
	0x25, 0x8a, 0x91, 0x33, 0xf0, 0x40, 0xd5, 0xa4, 0x7d, 0x95, 0xc1, 0x07, 0x60, 0x76, 0x48, 0x9b,
	0x32, 0xc4, 0xb0, 0xf5, 0x3f, 0x31, 0xd7, 0x4a, 0x1f, 0xe9, 0x41, 0x0e, 0x73, 0xf2, 0x9a, 0x4c,
	0x2c, 0xe1, 0x37, 0x60, 0x01, 0xed, 0x21, 0x12, 0xa0, 0x6e, 0x80, 0x65, 0xba, 0x5d, 0x9e, 0x39,
	0xeb, 0x86, 0xea, 0x15, 0x95, 0x64, 0x7e, 0x41, 0xdb, 0xea, 0x82, 0xb6, 0x6b, 0x94, 0x44, 0xaa,
	0xef, 0xe0, 0xb1, 0xb1, 0x48, 0xba, 0xb8, 0x91, 0xee, 0x01, 0xb0, 0x83, 0xb1, 0xcb, 0xf8, 0x1d,
	0x99, 0x5a, 0x45, 0x31, 0x30, 0xcf, 0x19, 0xb7, 0xfa, 0x2a, 0x75, 0x72, 0x3b, 0xea, 0x2f, 0x85,
	0x5f, 0x81, 0x09, 0xe9, 0x50, 0xf9, 0x63, 0x0e, 0xf1, 0x9d, 0xa4, 0x43, 0x12, 0x0d, 0xd7, 0xc0,
	0xdc, 0x30, 0xbc, 0x6e, 0x1f, 0x93, 0x5e, 0x9f, 0x59, 0x37, 0xcb, 0xc6, 0xea, 0xb8, 0x33, 0xeb,
	0xe9, 0xb8, 0x3d, 0x14, 0x62, 0x8e, 0x1d, 0xc4, 0xfe, 0x29, 0xec, 0x8a, 0xc4, 0x2a, 0xc5, 0x31,
	0xb6, 0x06, 0xc0, 0x48, 0xda, 0x6e, 0x7d, 0x52, 0xda, 0xc6, 0x44, 0xda, 0x72, 0xc7, 0xdb, 0x72,
	0x92, 0xe1, 0x86, 0xd6, 0xff, 0x3f, 0x87, 0xe4, 0xf8, 0x3c, 0x8f, 0x32, 0xd9, 0x45, 0x73, 0xe9,
	0x51, 0x26, 0x5b, 0x30, 0xaf, 0x3f, 0xca, 0x64, 0x4b, 0x66, 0x79, 0xe5, 0xb5, 0x01, 0xf2, 0x27,
	0xee, 0x1c, 0x58, 0x03, 0x26, 0x8d, 0x71, 0xc2, 0xff, 0xdd, 0x4f, 0x7d, 0x9b, 0xcc, 0x6a, 0x0b,
	0xdd, 0xae, 0x37, 0x00, 0x20, 0xa9, 0x8b, 0x23, 0x9e, 0x56, 0x5f, 0x3c, 0x1f, 0xb2, 0x4e, 0x8e,
	0xa4, 0x0d, 0x29, 0x80, 0x6d, 0x90, 0xe7, 0x63, 0x8b, 0xfb, 0x22, 0x9b, 0x65, 0xfc, 0x52, 0xcd,
	0x32, 0x23, 0x49, 0x64, 0x9f, 0xac, 0xfd, 0x61, 0x80, 0xdc, 0x71, 0x4e, 0xe1, 0x97, 0x60, 0xa9,
	0xf5, 0xec, 0xd9, 0x96, 0xdb, 0xee, 0x54, 0x3b, 0x0d, 0x77, 0xfb, 0x69, 0xbb, 0xd5, 0xa8, 0x35,
	0xef, 0x37, 0x1b, 0x75, 0x73, 0xac, 0x30, 0x7b, 0x78, 0x54, 0x9e, 0xde, 0x8e, 0xd2, 0x18, 0x7b,
	0x64, 0x87, 0x60, 0xfe, 0x28, 0x81, 0x23, 0xe0, 0x9a, 0xd3, 0xa8, 0x76, 0x1a, 0x75, 0xd3, 0x28,
	0x4c, 0x1f, 0x1e, 0x95, 0xa7, 0x54, 0xcb, 0xc0, 0x12, 0x30, 0x47, 0x40, 0x4e, 0xa3, 0x5a, 0x7f,
	0x61, 0x5e, 0x29, 0xe4, 0x0e, 0x8f, 0xca, 0x13, 0x0e, 0x46, 0xfe, 0x01, 0xbc, 0x09, 0xe6, 0x46,
	0x00, 0xad, 0xea, 0x76, 0xbb, 0x51, 0x37, 0xc7, 0x0b, 0xe0, 0xf0, 0xa8, 0x3c, 0xd9, 0x42, 0x83,
	0x14, 0xfb, 0xa7, 0x20, 0x8f, 0x9b, 0x5b, 0x5b, 0x8d, 0xba, 0x99, 0x91, 0x90, 0xc7, 0x24, 0x08,
	0xb0, 0x5f, 0xc8, 0xfc, 0xf2, 0x5b, 0xd1, 0x58, 0xfb, 0x01, 0x64, 0xf5, 0x43, 0x02, 0xae, 0x81,
	0x45, 0x61, 0xd4, 0x79, 0xd1, 0xba, 0xd0, 0x93, 0x15, 0xb5, 0x81, 0xc0, 0xb6, 0x3b, 0xd5, 0xc7,
	0xcd, 0xa7, 0x0f, 0xb4, 0x23, 0x6d, 0x86, 0x76, 0x49, 0xd4, 0x93, 0x3b, 0x6c, 0x3e, 0x78, 0xfd,
	0xae, 0x68, 0xbc, 0x79, 0x57, 0x34, 0xfe, 0x7d, 0x57, 0x34, 0x5e, 0xbd, 0x2f, 0x8e, 0xbd, 0x79,
	0x5f, 0x1c, 0xfb, 0xeb, 0x7d, 0x71, 0xec, 0xdb, 0xf5, 0x91, 0xf0, 0x07, 0x83, 0x70, 0x5d, 0xbf,
	0x6b, 0xc5, 0x13, 0xae, 0xb2, 0x3f, 0x7c, 0xdf, 0x8a, 0x4c, 0x74, 0x27, 0x45, 0xf5, 0xdd, 0xfd,
	0x2f, 0x00, 0x00, 0xff, 0xff, 0x29, 0xa0, 0x27, 0x16, 0x18, 0x0c, 0x00, 0x00,
}

func (m *FeeTaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeTaker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeTaker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintPool(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintPool(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xa2
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintPool(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0x9a
	if m.UpdatedAtHeight != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.UpdatedAtHeight))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.State != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if len(m.FeeTakers) > 0 {
		for iNdEx := len(m.FeeTakers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeTakers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	{
		size, err := m.AvailablePrizePool.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xea
	if m.LastDrawState != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.LastDrawState))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.LastDrawCreatedAt != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.LastDrawCreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.LastDrawCreatedAt):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintPool(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	{
		size := m.SponsorshipAmount.Size()
		i -= size
		if _, err := m.SponsorshipAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xca
	if m.DepositorsCount != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.DepositorsCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	{
		size := m.TvlAmount.Size()
		i -= size
		if _, err := m.TvlAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	if m.NextDrawId != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.NextDrawId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.IcaPrizepoolAddress) > 0 {
		i -= len(m.IcaPrizepoolAddress)
		copy(dAtA[i:], m.IcaPrizepoolAddress)
		i = encodeVarintPool(dAtA, i, uint64(len(m.IcaPrizepoolAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.IcaDepositAddress) > 0 {
		i -= len(m.IcaDepositAddress)
		copy(dAtA[i:], m.IcaDepositAddress)
		i = encodeVarintPool(dAtA, i, uint64(len(m.IcaDepositAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.LocalAddress) > 0 {
		i -= len(m.LocalAddress)
		copy(dAtA[i:], m.LocalAddress)
		i = encodeVarintPool(dAtA, i, uint64(len(m.LocalAddress)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	{
		size := m.MaxUnbondingEntries.Size()
		i -= size
		if _, err := m.MaxUnbondingEntries.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	n5, err5 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(m.UnbondingDuration, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.UnbondingDuration):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintPool(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size, err := m.PrizeStrategy.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.DrawSchedule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size := m.MinDepositAmount.Size()
		i -= size
		if _, err := m.MinDepositAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	if len(m.Bech32PrefixValAddr) > 0 {
		i -= len(m.Bech32PrefixValAddr)
		copy(dAtA[i:], m.Bech32PrefixValAddr)
		i = encodeVarintPool(dAtA, i, uint64(len(m.Bech32PrefixValAddr)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Bech32PrefixAccAddr) > 0 {
		i -= len(m.Bech32PrefixAccAddr)
		copy(dAtA[i:], m.Bech32PrefixAccAddr)
		i = encodeVarintPool(dAtA, i, uint64(len(m.Bech32PrefixAccAddr)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Validators) > 0 {
		for iNdEx := len(m.Validators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPool(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.PoolType != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.PoolType))
		i--
		dAtA[i] = 0x48
	}
	if len(m.IcaPrizepoolPortId) > 0 {
		i -= len(m.IcaPrizepoolPortId)
		copy(dAtA[i:], m.IcaPrizepoolPortId)
		i = encodeVarintPool(dAtA, i, uint64(len(m.IcaPrizepoolPortId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IcaDepositPortId) > 0 {
		i -= len(m.IcaDepositPortId)
		copy(dAtA[i:], m.IcaDepositPortId)
		i = encodeVarintPool(dAtA, i, uint64(len(m.IcaDepositPortId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TransferChannelId) > 0 {
		i -= len(m.TransferChannelId)
		copy(dAtA[i:], m.TransferChannelId)
		i = encodeVarintPool(dAtA, i, uint64(len(m.TransferChannelId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintPool(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintPool(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NativeDenom) > 0 {
		i -= len(m.NativeDenom)
		copy(dAtA[i:], m.NativeDenom)
		i = encodeVarintPool(dAtA, i, uint64(len(m.NativeDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPool(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintPool(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PoolValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BondedAmount.Size()
		i -= size
		if _, err := m.BondedAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPool(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IsEnabled {
		i--
		if m.IsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintPool(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPool(dAtA []byte, offset int, v uint64) int {
	offset -= sovPool(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FeeTaker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovPool(uint64(l))
	return n
}

func (m *Pool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovPool(uint64(m.PoolId))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.NativeDenom)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.TransferChannelId)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.IcaDepositPortId)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.IcaPrizepoolPortId)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	if m.PoolType != 0 {
		n += 1 + sovPool(uint64(m.PoolType))
	}
	if len(m.Validators) > 0 {
		for _, e := range m.Validators {
			l = e.Size()
			n += 1 + l + sovPool(uint64(l))
		}
	}
	l = len(m.Bech32PrefixAccAddr)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = len(m.Bech32PrefixValAddr)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	l = m.MinDepositAmount.Size()
	n += 1 + l + sovPool(uint64(l))
	l = m.DrawSchedule.Size()
	n += 1 + l + sovPool(uint64(l))
	l = m.PrizeStrategy.Size()
	n += 1 + l + sovPool(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(m.UnbondingDuration)
	n += 2 + l + sovPool(uint64(l))
	l = m.MaxUnbondingEntries.Size()
	n += 2 + l + sovPool(uint64(l))
	l = len(m.LocalAddress)
	if l > 0 {
		n += 2 + l + sovPool(uint64(l))
	}
	l = len(m.IcaDepositAddress)
	if l > 0 {
		n += 2 + l + sovPool(uint64(l))
	}
	l = len(m.IcaPrizepoolAddress)
	if l > 0 {
		n += 2 + l + sovPool(uint64(l))
	}
	if m.NextDrawId != 0 {
		n += 2 + sovPool(uint64(m.NextDrawId))
	}
	l = m.TvlAmount.Size()
	n += 2 + l + sovPool(uint64(l))
	if m.DepositorsCount != 0 {
		n += 2 + sovPool(uint64(m.DepositorsCount))
	}
	l = m.SponsorshipAmount.Size()
	n += 2 + l + sovPool(uint64(l))
	if m.LastDrawCreatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.LastDrawCreatedAt)
		n += 2 + l + sovPool(uint64(l))
	}
	if m.LastDrawState != 0 {
		n += 2 + sovPool(uint64(m.LastDrawState))
	}
	l = m.AvailablePrizePool.Size()
	n += 2 + l + sovPool(uint64(l))
	if len(m.FeeTakers) > 0 {
		for _, e := range m.FeeTakers {
			l = e.Size()
			n += 2 + l + sovPool(uint64(l))
		}
	}
	if m.State != 0 {
		n += 2 + sovPool(uint64(m.State))
	}
	if m.CreatedAtHeight != 0 {
		n += 2 + sovPool(uint64(m.CreatedAtHeight))
	}
	if m.UpdatedAtHeight != 0 {
		n += 2 + sovPool(uint64(m.UpdatedAtHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 2 + l + sovPool(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 2 + l + sovPool(uint64(l))
	return n
}

func (m *PoolValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovPool(uint64(l))
	}
	if m.IsEnabled {
		n += 2
	}
	l = m.BondedAmount.Size()
	n += 1 + l + sovPool(uint64(l))
	return n
}

func sovPool(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPool(x uint64) (n int) {
	return sovPool(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FeeTaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeTaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeTaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NativeDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcaDepositPortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IcaDepositPortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcaPrizepoolPortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IcaPrizepoolPortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolType", wireType)
			}
			m.PoolType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolType |= PoolType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validators = append(m.Validators, PoolValidator{})
			if err := m.Validators[len(m.Validators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32PrefixAccAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32PrefixAccAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bech32PrefixValAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bech32PrefixValAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDepositAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDepositAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawSchedule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DrawSchedule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrizeStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrizeStrategy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(&m.UnbondingDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnbondingEntries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxUnbondingEntries.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcaDepositAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IcaDepositAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcaPrizepoolAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IcaPrizepoolAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextDrawId", wireType)
			}
			m.NextDrawId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextDrawId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TvlAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TvlAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositorsCount", wireType)
			}
			m.DepositorsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositorsCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SponsorshipAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SponsorshipAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDrawCreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastDrawCreatedAt == nil {
				m.LastDrawCreatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.LastDrawCreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDrawState", wireType)
			}
			m.LastDrawState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDrawState |= DrawState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailablePrizePool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvailablePrizePool.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeTakers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeTakers = append(m.FeeTakers, &FeeTaker{})
			if err := m.FeeTakers[len(m.FeeTakers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PoolState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAtHeight", wireType)
			}
			m.UpdatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPool
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPool
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPool
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPool
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BondedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPool(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPool
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPool(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPool
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPool
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPool
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPool
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPool
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPool        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPool          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPool = fmt.Errorf("proto: unexpected end of group")
)
